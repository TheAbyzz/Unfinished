; When I tried to assemble and link the program below with the following command: nasm -felf64 pie.asm && gcc pie.o

  section .data
       msg: db "Hello world!",0x0a,0        
 
  section .text
 	 global main
 	 extern printf
 
  main: push rbp
        mov  rbp, rsp
        lea  rdi, [msg]
        xor  rax, rax
        call printf
 
        xor  rax, rax
        leave
        ret 

; I received the following error message:
;
; /usr/bin/ld: bill calculator.o: relocation R_X86_64_32S against `.data' can not be used when making a PIE object; recompile with -fPIC
; /usr/bin/ld: final link failed: Nonrepresentable section on output
; collect2: error: ld returned 1 exit status
;
; R_86_64_32S is one of several relocation types generated by the assembler and it tells the linker what kind of relocation (address adjustmet)
; has to be performed. R_86_64_32S means take the value at the offset in the relocation entry, add a symbolic value + any addend to it, trunctate
; the result to 32 bits and finally check that result sign-extends to the orginial value/result? before storing the result back at the same offset.
; The sign-extension is checked to verify that the size of the program doesn't exceed the capability of 32 bit absolute addressing e.g. some addresses
; of data or functions may lie too far from where are referenced.
; The virtual addresses are also split into 2 parts, so called lower and higher half with a non valid (noncanonical) region in between.
;
; nasm -felf64 pie.asm 
; readelf -r pie.o
;
;  ----------------------------------------------------------------------------------
; | Relocation section '.rela.text' at offset 0x340 contains 2 entries:              |
; |   Offset          Info           Type           Sym. Value    Sym. Name + Addend |
; | 000000000008  00020000000b R_X86_64_32S      0000000000000000 .data + 0          |
; | 000000000011  000500000009 R_X86_64_GOTPCREL 0000000000000000 printf - 4         |
;  ----------------------------------------------------------------------------------
;
; objdump -d -Mintel pie.o
; 
;  -----------------------------------------------------------------------------------
; | pie.o:     file format elf64-x86-64                                               |
; |                                                                                   |
; |                                                                                   |
; | Disassembly of section .text:                                                     |
; |                                                                                   |
; | 0000000000000000 <main>:                                                          |
; |    0: 55                    push   rbp                                            |        
; |    1: 48 89 e5              mov    rbp,rsp                                        |
; |    4: 48 8d 3c 25 00 00 00  lea    rdi,ds:0x0                                     |
; |    b: 00                                                                          |
; |    c: 48 31 c0              xor    rax,rax                                        |
; |    f: ff 15 00 00 00 00     call   QWORD PTR [rip+0x0]        # 15 <main+0x15>    |
; |   15: 48 31 c0              xor    rax,rax                                        |
; |   18: c9                    leave                                                 |
; |   19: c3                    ret                                                   |
;  -----------------------------------------------------------------------------------
;
; If the object file were to turn into an executable that was based on 32 bit absolute addressing and that was placed under the 2 GiB limit at a known 
; load address the following would occur:

;  --------------------------------------------                     ------------------------------------------
; | 4: 48 8d 3c 25 00 00 00  lea    rdi,ds:0x0 | --> (LINKING) --> |                               
; | b: 00                                      |                   |
;  --------------------------------------------                     ------------------------------------------
;
; It's not though cause the linker is configured with --enable-default-pie flag and therefore attemps to link the object file as a position independent
; exectuable aka pie. Pie is based on relative addressing and can thus be placed anywhere in the memory at a load address. In short there's a conflict 
; between the code and the linkers assumption about the code.
;
; We've got 2 options 
;
; 1. Override the default behaviour of the linker by issuing the following command: nasm -felf64 pie.asm && gcc -no-pie pie.o
;
;    This would give us an  
;
; 2. Make the necessary changes in the code to get a tasty pie
;
;    a) To solve the error above we should do one of the following fixes:
;    
;          lea rdi, [msg] --> lea rdi, [rel msg]
;
;          lea rdi, [msg] --> mov qword msg
;
;          default rel (add the directive somewhere in the code, not inside the sections though)
;
;    Now if we try to compile & link the program with: nasm -felf64 pie.asm && gcc pie.o
;    we get the error:
;
;    ./a.out: Symbol `printf' causes overflow in R_X86_64_PC32 relocation
;    Segmentation fault (core dumped)
;
;    b) To solve this error it turns out we have to do one the following fixes
;
;       call printf --> call printf WRT ..plt
;
;       call printf --> call [rel printf WRT ..got] (rel can be omitted if we added default rel) 
;    
; Here's complete version:
;
;   section .data
       msg: db "Hello world!",0x0a,0        
 
  section .text
       global main
       extern printf
 
  ; The "rel" keyword can be omitted if "default rel" is added here
 
  main: push rbp
        mov  rbp, rsp
        lea  rdi, [rel msg] ; or mov rdi, qword msg (64 bit absolute addressing)
        xor  rax, rax
        call [rel printf WRT ..got] ; or call printf WRT ..plt
 
        xor  rax, rax
        leave
        ret

; That's it! This was a simple introduction to a somewhat advanced topic was written by a rookie. There might be misstakes here and there
; and I'm going to come back to improve it. You'll find articles onlines written by wizards, who will lead deeper into the rabbit hole.
; It will serve more as a light and eye opening introduction into a intresting topic.


https://www.cs.swarthmore.edu/~kwebb/cs31/s15/bucs/virtual_memory_is.html
https://www.bottomupcs.com/virtual_memory_is.xhtml
http://reader.epubee.com/books/mobile/ee/ee571bde060c36770e1b10573760804f/text00107.html
https://stackoverflow.com/questions/6093547/what-do-r-x86-64-32s-and-r-x86-64-64-relocation-mean
https://stackoverflow.com/questions/2463150/what-is-the-fpie-option-for-position-independent-executables-in-gcc-and-ld/51308031#51308031
https://www.quora.com/What-is-PC-relative-addressing

https://stackoverflow.com/questions/10486116/what-does-this-gcc-error-relocation-truncated-to-fit-mean
https://www.technovelty.org/c/relocation-truncated-to-fit-wtf.html
https://stackoverflow.com/questions/33318342/when-is-it-better-for-an-assembler-to-use-sign-extended-relocation-like-r-x86-64

which basically means "the value of the symbol pointed to by this relocation, plus any addend", in both cases. For R_X86_64_32S the linker then verifies that the generated value sign-extends to the original 64-bit value.
https://stackoverflow.com/questions/6093547/what-do-r-x86-64-32s-and-r-x86-64-64-relocation-mean

;
; What happened as far as I understand was that the linker, which is configured with --enable-default-pie flag noticed that the code
; wasen't written/assembled for position independent executable aka pie and therefore refused to proceed. Pie uses relative
; addressing, which makes placing the pie anywhere in the virtual memory possible but more on this later. The program above uses
; () absolute adressing and thus cannot be placed anywhere in the virtual memory and certainly not above the () bound. Let's go back
; in time to see where it all started. Before memory management unit (mmu) and virtual addresses where invented the addressing of
; programs were based on real physical addresses and to allow multiple programs to be loaded on memory and perhaps even run simultaneously, 
; they couldn't used addressing that was based on fixed addresses, instead they used something called relative addressing and programs
; where this was utilized were called position independent executables (pie). I'm not going to go into great detail on how relative addressing was 
; implemented back then but the principle is that the addresses of data segments that are initialized prior to program execution are calculated
; using offsets and some base address. Once mmu and virtual addresses were invented there was no real use for pie anymore or was there? I'm not 
; sure. Pie or position independent code (pic) as it was this time called made it back to the surface in the form of a shared/dynamic library.
; A shared or dynamic library is a library that's not statically linked and one that can be shared by multiple programs simultaneously hence the
; name. Another technique used for shared/dynamic libraries called load-time relocation emerged around the same time. Let's cover load-time
; relocation first and briefly. When a program calls for a function in shared/dynamic library that library if not already present gets first 
; loaded into the process space of the program and then linked. The downside of this approach is that every program needs their own copy of that 
; library, which makes ram usage less efficient and every single program has to go through process of loading and linking before the function
; could finally be called and that slowed down things a bit. Pie solved both of these problems by allowing one single copy of the library to be
; shared by multiple programs. Shared/dynamic libraries implemented as pie were not loaded into the process space of an already existing program.
; Please note that both of these techniques emerged before x86_64 and that load-time relocation might not even work on x86_64. Maybe the advantages
; of the pie enetually lead to the neglection of load-time relocation, who knows? The earlier platforms were not designed with pic in mind and
; therefore it wasen't as efficiently implimented as it now on x86_64. As we move to 64 bit systems things change a bit. Now we have 2 types of
; shared/dynamic libraries; dynamically loaded libraries and dynamically linked libraries. Dynamically loaded libraries if not already present are
; loaded and linked by the program via requests. The program has full control over the usage of the library and this approach is commonly used in
; plugin programing. Dynamically linked libraries if not already present are loaded and linked by the OS as the program launches. Later (32 bit) it became
; common practise to make the executables themseleves (non libraries) pie allowing for something called address space layout randomization (aslr),
; which makes exploiting vulnerabilities harder. Pic name appears to be used as a generic name for code where the particular technique is used
; whereas pie is exlusivly used for executables (non libraries).

; We have 2 options to get the program above work
;
; 1. We could assemble and link the program above as non position independent executable
;
;    nasm -felf64 pie.asm && gcc -no-pie pie.o
;
; 2. We could make the necessary changes in the program above and assemble and link it as pie without -no-pie flag

  section .data
       msg: db "Hello world!",0x0a,0        
 
  section .text
       global main
       extern printf
 
  ; The "rel" keyword can be omitted if "default rel" is added here
 
  main: push rbp
        mov  rbp, rsp
        lea  rdi, [rel msg] ; or mov rdi, qword msg (64 bit absolute addressing)
        xor  rax, rax
        call [rel printf WRT ..got] ; or call printf WRT ..plt
 
        xor  rax, rax
        leave
        ret

; The missing "rel" keyword in "lea rdi, [msg]" caused the earlier error meassage
;
; /usr/bin/ld: bill calculator.o: relocation R_X86_64_32S against `.data' can not be used when making a PIE object; recompile with -fPIC
; /usr/bin/ld: final link failed: Nonrepresentable section on output
; collect2: error: ld returned 1 exit status
;
; If we don't call printf as we do in the fixed version we'll get
;
; ./a.out: Symbol `printf' causes overflow in R_X86_64_PC32 relocation
; Segmentation fault (core dumped)

; -------------------------------------------------------------------------------------------------------------------------------------------

; 64-bit code on OS X can't use 32-bit absolute addressing at all. Executables are loaded at a base address above 4GiB, so label addresses 
; just plain don't fit in 32-bit integers, with zero- or sign-extension. RIP-relative addressing is the best / most efficient solution, 
; whether you need it to be position-independent or not1.
https://stackoverflow.com/questions/47300844/mach-o-64-bit-format-does-not-support-32-bit-absolute-addresses-nasm-accessing

; 32-bit absolute relocation aren't allowed in an ELF shared object; that would stop them from being loaded outside the low 2GiB 
; (for sign-extended 32-bit addresses). 64-bit absolute addresses are allowed, but generally you only want that for jump tables or other static 
; data, not as part of instructions.1
https://stackoverflow.com/questions/43367427/32-bit-absolute-addresses-no-longer-allowed-in-x86-64-linux/46493456

; x86 code models
https://eli.thegreenplace.net/2012/01/03/understanding-the-x64-code-models

; relocations explained
https://www.intezer.com/blog/elf/executable-and-linkable-format-101-part-3-relocations/

; relative 32 bit jump is more efficient thant 64 absolute jump
https://stackoverflow.com/questions/26955200/why-does-jmpq-of-x86-64-only-need-32-bit-length-address

; with and without -fpic
https://unix.stackexchange.com/questions/116327/loading-of-shared-libraries-and-ram-usage

; plt and got
https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html

; The R_X86_64_32 and R_X86_64_32S relocations truncate the computed value to 32-bits. The linker must verify that the generated value for the 
; R_X86_64_32 (R_X86_64_32S) relocation zero-extends (sign-extends) to the original 64-bit value. 

; Most programs are compiled in a way that they use shared libraries. Those libraries are not part of the program image (even though it is 
; possible to include them via static linking) and therefore have to be referenced (included) dynamically. As a result, we see the libraries 
; (libc, ld, etc.) being loaded in the memory layout of a process. Roughly speaking, the shared libraries are loaded somewhere in the memory 
; (outside of process’ control) and our program just creates virtual “links” to that memory region. This way we save memory without the need 
; to load the same library in every instance of a program.

; How does the shared library access externally the data from the calling process?
